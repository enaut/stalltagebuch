---
name: makei18n
description: Internationalize a Dioxus 0.7 component and update locales via dx-i18n.
argument-hint: Inputs: selected file(s), default locale file path (e.g., locales/de-DE.ftl), optional target locales.
---
Generalize the selected code for internationalization in a Dioxus 0.7 application.

Goals:
- Translate visible UI text to the target language and make all strings translatable using dioxus-i18n.
- Replace hardcoded strings in RSX with translation lookups via the `t!` macro.
- Keep the implementation idiomatic for Dioxus 0.7 (no `cx`/`Scope`/`use_state`; prefer `use_signal`, `use_memo`, `use_resource`).
- Use `dx-i18n` to extract and maintain keys; do not hand-edit locale files beyond what `dx-i18n` outputs.

Instructions:
1) Analyze the selected file(s)
- Identify all user-visible strings in RSX nodes, attributes (e.g., `placeholder`, `value`, `aria-*`), and messages (e.g., errors, toasts, headings, labels, option texts).
- Normalize option values to stable internal identifiers where applicable (avoid localized values in `value`; use a parser or enum helpers where available).

2) Apply dioxus-i18n
- Import `dioxus_i18n::t`.
- For RSX text nodes, wrap the translation call in braces: `h2 { { t!("key") } }`.
- For attribute values, call `t!("key")` directly: `placeholder: t!("key")`.
- Use parameters for interpolations: `t!("key-with-param", name: some_string.clone())`.
- Keep emojis or icons as part of the localized string only if they are intended to be localized; otherwise keep them in code and concatenate the translated label.
- add comments in the end of the line for context if needed: `// i18n: Button to save the event`

3) Define translation keys
- Create clear, consistent keys grouped by feature (e.g., `event-add-title`, `field-date`, `error-invalid-date`).
- Prefer reusing existing action keys (e.g., `action-save`, `action-cancel`) instead of duplicating them.
- Avoid manual editing of locale files besides key additions generated by `dx-i18n`.

4) Update locales using dx-i18n
- Run the extractor to collect keys and update the default locale file:
  - Command: `dx-i18n -o <default-locale-file-path>`
  - Example: `dx-i18n -o locales/de-DE.ftl`
- Do not manually create additional locale files.

5) Translate the generated keys
- translate the new keys in the default locale files.
- make sure the translations are accurate and contextually appropriate.

6) i18n configuration
- Ensure the i18n config loads the default generated locale file.
- Only add additional locales after their files exist and are managed through the extraction workflow.

7) Code quality
- Keep changes minimal and focused on i18n; do not reformat unrelated code.
- Ensure RSX compiles: wrap `t!` in `{ ... }` for text nodes; no unnecessary braces for attribute values.
- If enum/string mapping exists, ensure select `value` matches internal slugs and `onchange` converts back via a helper `from_str` if available.

8) Deliverables
- Provide the patched code snippets for the selected file(s).

Example patterns (Dioxus 0.7):
- Text node: `h2 { { t!("page-title") } }`
- Attribute: `placeholder: t!("search-placeholder")`
- Parameterized: `{ t!("greeting-user", name: user_name.clone()) }`
- Select options with stable values:
  - `option { value: "alive", { t!("status-alive") } }`
  - `onchange: move |e| set_status(Status::from_str(e.value().as_str()))`

Please proceed to:
- Apply the above steps to the selected code.